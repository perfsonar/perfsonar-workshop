# A colorful .bashrc for modern Linux hosts

# Source global definitions
if [ -f /etc/bashrc ]; then
	. /etc/bashrc
fi

# History mgmt: ignoredups and ignorespace, append to the history file, don't overwrite it
export HISTCONTROL=ignoreboth
export HISTSIZE=9999
export HISTFILESIZE=9999
shopt -s histappend
# keep multi-seesion history fine
PROMPT_COMMAND='history -a'

# Prompt formating using tput
ME="sgr0"
AF="setaf"
MD="bold"
# How many colors can we print?
if [[ $TERM == 'xterm' || $TERM =~ 'screen' ]]; then
    # Try to set a higher standard
    export TERM="xterm-256color"
    if [ $(tput colors) -lt 9 ]; then
        # revert back to regular xterm
        export TERM="xterm"
    fi
fi
colors=$(tput colors 2>/dev/null)
if [ $? -ne 0 ]; then
    colors=2
fi
if [ $colors -gt 2 ]; then
    # Let's hope for at least 8 colors
    export CLICOLOR=1
    export LSCOLORS=ExGxFxDxCxDaDaabagecec
    alias ls='ls --color=auto'
    export PAGER="less -sRM"
    [ -x /usr/bin/dircolors ] && eval "`dircolors -b`"
    export LESS="--RAW-CONTROL-CHARS"
    alias grep='grep --color=auto'
    export GREP_COLOR='39;33'
    P_HOME="$(tput ${MD} && tput ${AF} 3)"
    P_OK="$(tput ${MD} && tput ${AF} 2)"
    P_ERROR="$(tput ${MD} && tput ${AF} 1)"
    P_WARNING="$(tput ${MD} && tput ${AF} 3)"
    P_NORMAL="$(tput ${MD} && tput ${AF} 7)"
    P_INFO="$(tput ${MD} && tput ${AF} 6)"
fi
if [ $colors -gt 8 ]; then
    # Colorful less and grep output
    export LESS_TERMCAP_mb=$'\e[38;5;009m'
    export LESS_TERMCAP_md=$'\e[38;5;010m'
    export LESS_TERMCAP_me=$'\e[0m'
    export LESS_TERMCAP_se=$'\e[0m'
    export LESS_TERMCAP_so=$'\e[48;5;004m'
    export LESS_TERMCAP_ue=$'\e[0m'
    export LESS_TERMCAP_us=$'\e[38;5;012m'
    alias grep='grep --color=auto'
    export GREP_COLOR='38;5;208'
    # Colorful prompt
    P_HOME="$(tput ${AF} 11)"
    P_OK="$(tput ${AF} 10)"
    P_ERROR="$(tput ${AF} 9)"
    P_WARNING="$(tput ${AF} 214)"
    P_NORMAL="$(tput ${AF} 15)"
    P_INFO="$(tput ${AF} 12)"
fi
# Bold and reset should be supported on all terminals
P_BOLD="$([[ $colors -gt 2 ]] && tput ${MD})"
P_RESET="$([[ $colors -gt 2 ]] && tput ${ME})"

# A colorful bash prompt
p_result() {
    if [[ $? == 0 ]]; then
        printf "\[$P_NORMAL\]:)\[$P_RESET\]"
    else
        printf "\[$P_ERROR\]:(\[$P_RESET\]"
    fi
}
# Bold and reset should be supported on all terminals
P_BOLD="$([[ $colors -gt 2 ]] && tput ${MD})"
P_RESET="$([[ $colors -gt 2 ]] && tput ${ME})"

# PS1 needs to be re-evaluated after each command, because we use colors in the functions
set_bash_prompt() {
    PS1="${MY_PROMPT}$(p_result)${MY_PATH}$(prompt_git)\\$ "
}
PROMPT_COMMAND="set_bash_prompt; ${PROMPT_COMMAND}"
MY_PROMPT=""
MY_PATH=""

# UID
if [[ $EUID -eq 0 ]]; then
    MY_PROMPT="$MY_PROMPT"'\[$P_ERROR\]\u'
elif [[ -n "${SUDO_USER:-}" ]]; then
    MY_PROMPT="$MY_PROMPT"'\[$P_WARNING\]\u'
else
    MY_PROMPT="$MY_PROMPT"'\[$P_OK\]\u'
fi

# Shell level
if [[ ${SHLVL-0} -ne 1 ]]; then
    MY_PROMPT="$MY_PROMPT^$SHLVL"'\[$P_RESET\]'
fi

# Change color if we're root
if [[ $EUID -eq 0 ]]; then
    MY_PROMPT="${MY_PROMPT}"'\[$P_OK\]'"@"'\[$P_RESET\]'
else
    MY_PROMPT="${MY_PROMPT}"'\[$P_ERROR\]'"@"'\[$P_RESET\]'
fi

MY_PROMPT="$MY_PROMPT"'\[$P_HOME\]\h\[$P_RESET\]'
# Chroot jail path
if [[ -n "$chroot" ]]; then
    MY_PATH="$MY_PATH"'\[$P_WARNING\]'"$chroot"'\[$P_RESET\]'
fi

# Working directory, absolute path if we're in a chroot jail
MY_PATH="$MY_PATH"'\[$P_INFO\]'
if [[ -z "$chroot" ]]; then
    MY_PATH="$MY_PATH"'\w'
else
    MY_PATH="$MY_PATH"'$PWD'
fi
MY_PATH="$MY_PATH"'\[$P_RESET\]'

# Title bar
case "$TERM" in
    xterm*|rxvt*|Eterm|aterm|kterm|gnome*)
        MY_PATH="$MY_PATH"'\[\033]0;\u@\h:'"${chroot}"'${PWD}\007\]'
        ;;
    screen)
        MY_PATH="$MY_PATH"'\[\033_\u@\h:'"${chroot}"'${PWD}\033\\\'
        ;;
esac

# Running jobs, if any
prompt_jobs() {
    [ -n "$(jobs)" ] && printf '{%d}' $(jobs | sed -n '$=')
}
MY_PATH="$MY_PATH"'\[$P_WARNING\]'"\$(prompt_jobs)"'\[$P_RESET\]'

# Git prompt
prompt_git() {
    # Are we in a git repository?
    git branch --no-color &>/dev/null || return 1
    HEAD="$(git symbolic-ref HEAD 2>/dev/null)"
    BRANCH="${HEAD##*/}"
    GITSTATUS="$(LANG=C git status 2>/dev/null)"
    GITSTATUS=${GITSTATUS/\# /}
    [[ $GITSTATUS =~ working\ (directory|tree)\ clean ]] || STATUS="‚ùó "
    # How many local commits do we have ahead of origin?
    NUM=$(echo $GITSTATUS | awk '/Your branch is ahead of/ {print "+"$11;}') || ""
    printf "(git:\[$P_OK\]%s\[$P_RESET\]%s\[$P_WARNING\]%s\[$P_RESET\])" "${BRANCH:-unknown}" "\[$P_ERROR\]${STATUS}\[$P_RESET\]" "${NUM}"
}

# User specific aliases and functions
export EDITOR=vim
alias screen='screen -R -D'
alias psa='ps aux'
alias ll='ls -la'

